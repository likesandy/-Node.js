# 内置模块fs

* fs是File System的缩写，表示文件系统

* 对于任何一个为服务器端服务的语言或者框架通常都会有自己的文件系统
  * 因为服务器需要将各种数据、文件等放置到不同的地方
  * 比如用户数据可能大多数是放到数据库中的
  * 比如某些配置文件或者用户资源（图片、音视频）都是以文件的形式存在于操作系统上的

* Node也有自己的文件系统操作模块，就是fs
  * 借助于Node帮我们封装的文件系统，我们可以在任何的操作系统（window、Mac OS、Linux）上面直接去操作文件
  * 这也是Node可以开发服务器的一大原因，也是它可以成为前端自动化脚本等热门工具的原因

# fs的API介绍

* Node文件系统的API非常的多
  * [https://nodejs.org/dist/latest-v15.x/docs/api/fs.html](https://nodejs.org/dist/latest-v15.x/docs/api/fs.html)
  * 我们不可能，也没必要一个个去学习
  * 这个更多的应该是作为一个API查询的手册，等用到的时候查询即可
  * 学习阶段我们只需要学习最常用的即可

* 但是这些API大多数都提供三种操作方式
  * 方式一：同步操作文件：代码会被阻塞，不会继续执行
  * 方式二：异步回调函数操作文件：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数被执行
  * 方式三：异步Promise操作文件：代码不会被阻塞，通过 fs.promises 调用方法操作，会返回一个Promise，可以通过then、catch进行处理

# 文件描述符

* 文件描述符（File descriptors）是什么呢
  * POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格
  * 每个打开的文件都分配了一个称为文件描述符的简单的数字标识符
  * 在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件
  * Windows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源

* 为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符

* fs.open() 方法用于分配新的文件描述符
  * 一旦被分配，则文件描述符可用于从文件读取数据、向文件写入数据、或请求关于文件的信息

# 文件的读写
  
* 如果我们希望对文件的内容进行操作，这个时候可以使用文件的读写 
  * fs.readFile(path[, options], callback)：读取文件的内容
  * fs.writeFile(file, data[, options], callback)：在文件中写入内容

# flag选项

* 我们先来看flag

* flag的值有很多：[https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags](https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags)
  * w 打开文件写入，默认值
  * w+打开文件进行读写，如果不存在则创建文件
  * r+ 打开文件进行读写，如果不存在那么抛出异常
  * r打开文件读取，读取时的默认值
  * a打开要写入的文件，将流放在文件末尾。如果不存在则创建文件
  * a+打开文件以进行读写，将流放在文件末尾。如果不存在则创建文件

# encoding选项

* 文件读取
  * 如果不填写encoding，返回的结果是Buffer

# 文件夹操作

* 新建一个文件夹
  * 使用fs.mkdir()或fs.mkdirSync()创建一个新文件夹

* 


